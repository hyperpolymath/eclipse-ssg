// SPDX-License-Identifier: AGPL-3.0-or-later
// SPDX-FileCopyrightText: 2025 Jonathan D.A. Jewell
// compiler.ts â€” NoteG language compiler (to JavaScript)

import { Lexer } from "./lexer.ts";
import { Parser, ASTNode, ProgramNode, LetNode, FunctionNode, IfNode, ForNode, WhileNode, ReturnNode, BinaryExprNode, UnaryExprNode, CallNode, IdentifierNode, LiteralNode, ArrayNode, TemplateNode, BlockNode } from "./parser.ts";

// ============================================================
// COMPILER
// ============================================================

export class Compiler {
  private indent: number = 0;

  compile(program: ProgramNode): string {
    const lines: string[] = [
      "// Generated by NoteG Compiler",
      "// SPDX-License-Identifier: AGPL-3.0-or-later",
      "",
    ];

    for (const node of program.body) {
      lines.push(this.compileNode(node));
    }

    return lines.join("\n");
  }

  private compileNode(node: ASTNode): string {
    switch (node.type) {
      case "Let":
        return this.compileLet(node as LetNode);
      case "Function":
        return this.compileFunction(node as FunctionNode);
      case "If":
        return this.compileIf(node as IfNode);
      case "For":
        return this.compileFor(node as ForNode);
      case "While":
        return this.compileWhile(node as WhileNode);
      case "Return":
        return this.compileReturn(node as ReturnNode);
      case "Block":
        return this.compileBlock(node as BlockNode);
      case "BinaryExpr":
        return this.compileBinaryExpr(node as BinaryExprNode);
      case "UnaryExpr":
        return this.compileUnaryExpr(node as UnaryExprNode);
      case "Call":
        return this.compileCall(node as CallNode);
      case "Identifier":
        return (node as IdentifierNode).name;
      case "Literal":
        return this.compileLiteral(node as LiteralNode);
      case "Array":
        return this.compileArray(node as ArrayNode);
      case "Template":
        return this.compileTemplate(node as TemplateNode);
      default:
        throw new Error(`Unknown node type: ${(node as ASTNode).type}`);
    }
  }

  private compileLet(node: LetNode): string {
    const value = this.compileNode(node.value);
    return `${this.getIndent()}const ${node.name} = ${value};`;
  }

  private compileFunction(node: FunctionNode): string {
    const params = node.params.join(", ");
    const body = this.compileNode(node.body);
    return `${this.getIndent()}function ${node.name}(${params}) ${body}`;
  }

  private compileIf(node: IfNode): string {
    const condition = this.compileNode(node.condition);
    const thenBranch = this.compileNode(node.thenBranch);

    let result = `${this.getIndent()}if (${condition}) ${thenBranch}`;

    if (node.elseBranch) {
      const elseBranch = this.compileNode(node.elseBranch);
      result += ` else ${elseBranch}`;
    }

    return result;
  }

  private compileFor(node: ForNode): string {
    const iterable = this.compileNode(node.iterable);
    const body = this.compileNode(node.body);
    return `${this.getIndent()}for (const ${node.variable} of ${iterable}) ${body}`;
  }

  private compileWhile(node: WhileNode): string {
    const condition = this.compileNode(node.condition);
    const body = this.compileNode(node.body);
    return `${this.getIndent()}while (${condition}) ${body}`;
  }

  private compileReturn(node: ReturnNode): string {
    if (node.value) {
      const value = this.compileNode(node.value);
      return `${this.getIndent()}return ${value};`;
    }
    return `${this.getIndent()}return;`;
  }

  private compileBlock(node: BlockNode): string {
    this.indent++;
    const statements = node.statements.map((s) => this.compileNode(s)).join("\n");
    this.indent--;
    return `{\n${statements}\n${this.getIndent()}}`;
  }

  private compileBinaryExpr(node: BinaryExprNode): string {
    const left = this.compileNode(node.left);
    const right = this.compileNode(node.right);

    let op = node.operator;
    if (op === "and") op = "&&";
    if (op === "or") op = "||";

    return `(${left} ${op} ${right})`;
  }

  private compileUnaryExpr(node: UnaryExprNode): string {
    const operand = this.compileNode(node.operand);
    let op = node.operator;
    if (op === "not") op = "!";
    return `${op}${operand}`;
  }

  private compileCall(node: CallNode): string {
    const callee = this.compileNode(node.callee);
    const args = node.args.map((a) => this.compileNode(a)).join(", ");
    return `${callee}(${args})`;
  }

  private compileLiteral(node: LiteralNode): string {
    if (typeof node.value === "string") {
      return JSON.stringify(node.value);
    }
    if (node.value === null) {
      return "null";
    }
    return String(node.value);
  }

  private compileArray(node: ArrayNode): string {
    const elements = node.elements.map((e) => this.compileNode(e)).join(", ");
    return `[${elements}]`;
  }

  private compileTemplate(node: TemplateNode): string {
    return `\${${node.variable}}`;
  }

  private getIndent(): string {
    return "  ".repeat(this.indent);
  }
}

// ============================================================
// CLI ENTRY POINT
// ============================================================

if (import.meta.main) {
  const file = Deno.args[0];
  if (!file) {
    console.error("Usage: compiler.ts <file>");
    Deno.exit(1);
  }

  const source = await Deno.readTextFile(file);
  const lexer = new Lexer(source);
  const tokens = lexer.tokenize();
  const parser = new Parser(tokens);
  const ast = parser.parse();
  const compiler = new Compiler();
  const output = compiler.compile(ast);

  // Write output
  const outputFile = file.replace(/\.noteg$/, ".js");
  await Deno.writeTextFile(outputFile, output);
  console.log(`Compiled to ${outputFile}`);
}
